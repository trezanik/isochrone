project_name=$1
git_root=$2

# if !$1 or !$2 invalid


header_file="version.h"
url_prefix="https://github.com/trezanik/isochrone/commits/master"
file_head="#pragma once

// *** This file is automatically generated with each build; any and all changes will be lost! ***

#include <string>
#include \"version.tt\"

namespace trezanik {
namespace $project_name {
"
file_tail="
}
}"

curdir=$(pwd)
cd $git_root

# include deleted(-d), modified(-m), other(-o) and killed(-k) files in the determination.
# Byte count used as the indicator (0=false, >0=true)
dirty_flag=$(git ls-files --exclude-standard -d -m -o -k | wc -c)

gitval_copyright=$(git log -n 1 --format=format:"%an <%ae>" | sed '/\n\r/d')
gitval_commit_hash=$(git log -n 1 --format=format:"%H" | sed '/\n\r/d')
gitval_commit_date=$(git log -n 1 --date=short --format=format:"%ad" | sed '/\n\r/d')
gitval_abbrev_hash=$(git log -n 1 --date=short --format=format:"%h" | sed '/\n\r/d')

#stringify_def1="#define TZK_STRINGIFY(txt)    TZK_REAL_TEXT(txt)"
#stringify_def2="#define TZK_REAL_TEXT(txt)    #txt"
stringify_def1="#if !defined(TZK_STRINGIFY)
#	define TZK_STRINGIFY(txt)  TZK_REAL_TEXT(txt)
#endif
"
stringify_def2="#if !defined(TZK_REAL_TEXT)
#	define TZK_REAL_TEXT(txt)  #txt
#endif
"

# VERSION_INFO inside resource scripts can't use variables, so we have to provide definitions, which we assign to variables..
prod_ver_def="#define TZK_PROJECT_PROD_VER  TZK_STRINGIFY(TZK_PROJECT_VERSION_MAJOR) \".\" TZK_STRINGIFY(TZK_PROJECT_VERSION_MINOR) \".$gitval_commit_date.$gitval_abbrev_hash\"
"

repo_url="	const std::string  url = \"$url_prefix$gitval_commit_hash\";"
file_ver="	const std::string  file_version = TZK_STRINGIFY(TZK_PROJECT_VERSION_MAJOR) \".\" TZK_STRINGIFY(TZK_PROJECT_VERSION_MINOR);"
prod_ver="	const std::string  product_version = TZK_PROJECT_PROD_VER;"
copyright="	const std::string  copyright = \"$gitval_copyright\";"
dirty_txt="	const bool         dirty = static_cast<bool>("${dirty_flag}");"


out_path=./src/${project_name}/${header_file}

# write out to file, overwriting all existing content. Append until all content is written
echo "$file_head" > $out_path
echo "$stringify_def1" >> $out_path
echo "$stringify_def2" >> $out_path
echo "$prod_ver_def" >> $out_path
echo "$repo_url" >> $out_path
echo "$file_ver" >> $out_path
echo "$prod_ver" >> $out_path
echo "$copyright" >> $out_path
echo "$dirty_txt" >> $out_path
echo "$file_tail" >> $out_path

# restore original working location
cd $curdir
